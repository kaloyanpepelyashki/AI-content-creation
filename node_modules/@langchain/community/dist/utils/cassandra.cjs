"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CassandraClientFactory = void 0;
const cassandra_driver_1 = require("cassandra-driver");
const promises_1 = __importDefault(require("node:fs/promises"));
const path = __importStar(require("node:path"));
const os = __importStar(require("node:os"));
/**
 * A factory class for creating Cassandra clients.
 */
class CassandraClientFactory {
    /**
     * Get a Cassandra client with the provided arguments.
     * @param args The arguments for creating the Cassandra client.
     * @returns A Client object from the cassandra-driver.
     */
    static async getClient(args) {
        const modifiedArgs = await this.processArgs(args);
        return new cassandra_driver_1.Client(modifiedArgs);
    }
    /**
     * Process the arguments for creating a Cassandra client.
     * @param args The arguments for creating the Cassandra client.
     * @returns The processed arguments.
     * @throws Error if the configuration is unsupported (e.g. unknown service provider).
     */
    static processArgs(args) {
        if (!args.serviceProviderArgs) {
            return Promise.resolve(args);
        }
        if (args.serviceProviderArgs && args.serviceProviderArgs.astra) {
            return CassandraClientFactory.processAstraArgs(args);
        }
        throw new Error("Unsupported configuration for Cassandra client.");
    }
    /**
     * Process the arguments for creating a Cassandra client to Astra.
     * @param args The arguments for creating the Cassandra client.
     * @returns The processed arguments for connecting to Astra.
     * @throws Error if the Astra configuration is not provided.
     */
    static async processAstraArgs(args) {
        const astraArgs = args.serviceProviderArgs?.astra;
        if (!astraArgs) {
            throw new Error("Astra configuration is not provided in args.");
        }
        if (!astraArgs.endpoint && !astraArgs.datacenterID) {
            throw new Error("Astra endpoint or datacenterID must be provided in args.");
        }
        // Extract datacenterID and regionName from endpoint if provided
        if (astraArgs.endpoint) {
            const endpoint = new URL(astraArgs.endpoint.toString());
            const hostnameParts = endpoint.hostname.split("-");
            const domainSuffix = ".apps.astra.datastax.com";
            if (hostnameParts[hostnameParts.length - 1].endsWith(domainSuffix)) {
                astraArgs.datacenterID =
                    astraArgs.datacenterID || hostnameParts.slice(0, 5).join("-");
                // Extract regionName by joining elements from index 5 to the end, and then remove the domain suffix
                const fullRegionName = hostnameParts.slice(5).join("-");
                astraArgs.regionName =
                    astraArgs.regionName || fullRegionName.replace(domainSuffix, "");
            }
        }
        // Initialize cloud configuration if not already defined
        const modifiedArgs = {
            ...args,
            cloud: args.cloud || { secureConnectBundle: "" },
        };
        // Set default bundle location if it is not set
        if (!modifiedArgs.cloud.secureConnectBundle) {
            modifiedArgs.cloud.secureConnectBundle =
                await CassandraClientFactory.getAstraDefaultBundleLocation(astraArgs);
        }
        // Ensure secure connect bundle exists
        await CassandraClientFactory.setAstraBundle(astraArgs, modifiedArgs.cloud.secureConnectBundle);
        // Ensure credentials are set
        modifiedArgs.credentials = modifiedArgs.credentials || {
            username: "token",
            password: astraArgs.token,
        };
        return modifiedArgs;
    }
    /**
     * Get the default bundle location for Astra.
     * @param astraArgs The Astra service provider arguments.
     * @returns The default bundle file path.
     */
    static async getAstraDefaultBundleLocation(astraArgs) {
        const dir = path.join(os.tmpdir(), "cassandra-astra");
        await promises_1.default.mkdir(dir, { recursive: true });
        let scbFileName = `astra-secure-connect-${astraArgs.datacenterID}`;
        if (astraArgs.regionName) {
            scbFileName += `-${astraArgs.regionName}`;
        }
        scbFileName += ".zip";
        const scbPath = path.join(dir, scbFileName);
        return scbPath;
    }
    /**
     * Set the Astra bundle for the Cassandra client.
     * @param astraArgs The Astra service provider arguments.
     * @param scbPath The path to the secure connect bundle.
     * @returns Promise that resolves when the bundle is set.
     * @throws Error if the bundle URLs cannot be retrieved or the file cannot be downloaded.
     */
    static async setAstraBundle(astraArgs, scbPath) {
        // If scbPath is a URL, we assume the URL is correct and do nothing further.
        // But if it is a string, we need to check if the file exists and download it if necessary.
        if (typeof scbPath === "string") {
            try {
                // Check if the file exists
                const stats = await promises_1.default.stat(scbPath);
                // Calculate the age of the file in days
                const fileAgeInDays = (Date.now() - stats.mtime.getTime()) / (1000 * 60 * 60 * 24);
                // File is more than 360 days old, download a fresh copy
                if (fileAgeInDays > 360) {
                    await CassandraClientFactory.downloadAstraSecureConnectBundle(astraArgs, scbPath);
                }
            }
            catch (error) {
                if (typeof error === "object" &&
                    error !== null &&
                    "code" in error &&
                    error.code === "ENOENT") {
                    // Handle file not found error (ENOENT)
                    await CassandraClientFactory.downloadAstraSecureConnectBundle(astraArgs, scbPath);
                }
                else {
                    throw error;
                }
            }
        }
    }
    /**
     * Downloads the Astra secure connect bundle for the given Astra service provider arguments
     * and saves it to the specified file path.
     *
     * @param astraArgs - The Astra service provider arguments.
     * @param scbPath - The file path to save the secure connect bundle.
     * @returns A promise that resolves when the secure connect bundle is downloaded and saved.
     * @throws An error if there is an HTTP error or if the secure bundle URLs cannot be retrieved.
     */
    static async downloadAstraSecureConnectBundle(astraArgs, scbPath) {
        if (!astraArgs.datacenterID) {
            throw new Error("Astra datacenterID is not provided in args.");
        }
        // First POST request gets all bundle locations for the database_id
        const bundleURLTemplate = "https://api.astra.datastax.com/v2/databases/{database_id}/secureBundleURL?all=true";
        const url = bundleURLTemplate.replace("{database_id}", astraArgs.datacenterID);
        const postResponse = await fetch(url, {
            method: "POST",
            headers: {
                Authorization: `Bearer ${astraArgs.token}`,
                "Content-Type": "application/json",
            },
        });
        if (!postResponse.ok) {
            throw new Error(`HTTP error! Status: ${postResponse.status}`);
        }
        const postData = await postResponse.json();
        if (!postData || !Array.isArray(postData) || postData.length === 0) {
            throw new Error("Failed to get secure bundle URLs.");
        }
        // Find the download URL for the region, if specified
        let { downloadURL } = postData[0];
        if (astraArgs.regionName) {
            const regionalBundle = postData.find((bundle) => bundle.region === astraArgs.regionName);
            if (regionalBundle) {
                downloadURL = regionalBundle.downloadURL;
            }
        }
        // GET request to download the file itself, and write to disk
        const getResponse = await fetch(downloadURL);
        if (!getResponse.ok) {
            throw new Error(`HTTP error! Status: ${getResponse.status}`);
        }
        const bundleData = await getResponse.arrayBuffer();
        await promises_1.default.writeFile(scbPath, Buffer.from(bundleData));
    }
}
exports.CassandraClientFactory = CassandraClientFactory;
